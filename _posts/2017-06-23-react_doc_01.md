---
layout: post
title: ReactDoc | Reading React documentation Quick Start - 1. React / JSX / Elements
description: "React 공식 문서 읽기 01."
image: ../../assets/images/react_love.svg
tags:
  - react
  - react documentation
  - JSX
  - elements
  - ReactDOM
comments: true
# link: 'http://tryhelloworld.co.kr/challenge_codes/126'
---

![image](../../assets/images/react_love.png){: .center-image}

#### Summary

[01. Hello World](https://facebook.github.io/react/docs/hello-world.html)

POINT
: JavaScript 기반, ES6 문법 사용, Babel을 이용해 ES6를 컴파일!

[02. Introducing JSX](https://facebook.github.io/react/docs/introducing-jsx.html)

POINT
: JSX는 오브젝트를 만들어 DOM을 구성하는 데 필요한 정보를 만든다. 화면에 나타날 UI를 표현하기 위한 정보를 가지고 있다. 중괄호와 따옴표, React.createElement()를 기억!

[03. Rendering Elements](https://facebook.github.io/react/docs/rendering-elements.html)

POINT
: 요소란 무엇인가? - React 요소들은 root DOM 노드로 렌더링 된다. 이때 `ReactDOM.render()`를 사용(저기에 전달)한다.
: 요소의 특징들 - 변경 불가능, 한 시점의 UI를 표현,

---

## 1. Hello World

```javascript
ReactDOM.render(
  <h1>Hello, world!</h1>,
  document.getElementById('root')
);
```

> `ReactDOM` : React는 ReactDOM이라는 가상 DOM을 가지고 있다.
> `render()` : 여기에 HTML 코드들을 렌더 할 수 있다.

## 2. Introducing JSX

#### 1. JSX는 JavsScript 구문의 확장 버전이라고 이해할 수 있다. 화면에 UI가 어떻게 보여야 하는 지를 표현할 때 쓴다.
* React는 JavaScript 기반의 UI 라이브러리

#### 2. JSX는 React '요소(elements)'를 생성한다.

#### 3. `{}`(curly braces) : JavaScript 표현을 중괄호로 둘러싸는 방식을 통해 JSX를 사용한다.

```javascript
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

> `Hello, Harper Perez!`가 출력된다.

#### 4. **JSX는 표현식이다.**

컴파일이 끝나면 JSX 표현식은 일반 JavaScript **객체**가 된다. 즉, if문이나 for문 등을 사용할 수 있으며, 그 값들을 변수에 할당하고, 아규먼트로 그 값들을 받고, 함수에서 리턴할 수도 있다는 뜻이다.

```javascript
function getGreeting(user) {
  if (user) {
    return <h1>Hello, {formatName(user)}!</h1>;
  }
  return <h1>Hello, Stranger.</h1>;
}
```

#### 5. JSX로 속성지정하기 : 따옴표를 이용해 문자열 리터럴을 속성으로 지정할 수 있다. 혹은 중괄호를 이용해 JavaScript 표현식을 속성에 포함시킬 수도 있다.

```javascript
const element_quotes = <div tabIndex="0"></div>;

const element_curly = <img src={user.avatarUrl}></img>;
```
> 다만 JavaScript 표현식을 속성에 포함시킬 경우에는 중괄호에 따옴표를 사용해선 안된다. JSX가 속성을 표현식이 아닌 문자열 리터럴로 간주하게 되기 때문이다.
> 문자열 값에는 따옴표를, 표현식에는 중괄호를 쓰는 게 좋다. 다만 같은 속성에 두가지를 동시에 쓰지만 않으면 된다.

#### 6. JSX로 자식지정하기 : 만약 태그의 내용이 비어있다면, **XML**처럼 `/>`만 써서 마무리 해도 된다.

```javascript
const element = <img src={user.avatarUrl} />;
```

JSX 태그는 다음과 같이 자손을 지정할 수 있다.

```javascript
const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);
```

* 경고 : JSX가 HTML보다 JavaScript와 가깝기 때문에, React DOM은 HTML 속성 이름 대신 camelCase 방식의 속성표기법을 사용합니다.
ex) `class` -> `className`, `tabindex` -> `tabIndex`

#### 7. JSX는 injection attacks를 막는다.(?)

JSX에서는 user input을 집어넣어도 안전하다.

```javascript
const title = response.potentiallyMaliciousInput;
// This is safe:
const element = <h1>{title}</h1>;
```

기본적으로, React DOM은 렌더링하기 전에 JSX에 임베드된 모든 값을 이스케이프 처리한다. 따라서 어플리케이션에 명시적으로 작성되지 않은 내용은 이후에 절대 삽입할 수 없다.
모든 것은 렌더링되기 전에 문자열로 변환된다. **덕분에 XSS 공격을 방지할 수 있다.**

#### 8. **JSX는 객체를 나타낸다.**

Babel은 JSX를 `React.createElement()`로 호출함으로써 컴파일한다.

다음 두 예제는 동일하다.

```javascript
const element = {
  <h1 className = "greeting">
    Hello, world!
  </h1>
};
```

```javascript
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
)
```

> `React.createElement()`는 버그 없는 코드를 작성하는데 도움을 주는 몇가지 검사들을 수행한다. 하지만 기본적으로 다음과 같은 오브젝트를 만들어낸다.

```javascript
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};
```
> 이러한 오브젝트들을 가리켜 "React 요소elements"라고 부른다. **이 React 요소들이 스크린에서 구현하고자 하는 것을 설명한다**고 생각하면 된다. React는 이러한 오브젝트들을 읽어들여 DOM을 구성하는 데 사용하며 최신 상태로 유지한다.

## 3. Rendering Elements

`Elements`들은 React app을 구성하는 가장 작은 단위의 구성요소다. 하나의 element는 스크린에 표현하고자 하는 것을 표현한다.

브라우저의 DOM 요소와 달리, React 요소들은 일반 객체라 손쉽게 만들 수 있다. React DOM은 React 요소들과 일치하도록 DOM을 업데이트 한다. --> (?)

* 요소Element vs 컴포넌트Component
요소들은 컴포넌트들을 구성하는 더 작은 단위의 요소다. (?)

#### 1. Rendering an Element into the DOM

`<div>` 요소가 HTML 파일 어딘가에 있다고 해보자.

```javascript
<div id="root"></div>
```

이를 "root" DOM 노드라고 부른다. 이 내부의 모든 것들이 React DOM에 의해 관리되기 때문이다.

React로 만들어진 어플리케이션들은 보통 단일 root DOM 노드를 가진다. 만약 React를 기존의 app과 통합하려고 한다면, 원하는 만큼 많은 root DOM 노드들을 독립적으로 생성할 수 있다.

React 요소를 root DOM 노드로 렌더링 하려면, `ReactDOM.render()`에 모두 전달해야 한다.

다음 코드는 페이지에 "Hello, world!를 보여준다.

```javascript
const element = <h1>Hello, world!</h1>;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

```html
<div id="root">
    <!-- 이 요소의 내용은 컴포넌트로 대체된다. -->
</div>
```

#### 2. Updating the Rendered Element

React 요소들은 변경이 불가능(immutable)하다.
요소를 하나 만들고 난 뒤에는 그 요소의 자식이나 속성을 변경할 수 없다. 하나의 요소는 영화의 프레임 하나와 같다고 할 수 있다.: 하나의 요소는 **어떤 시점의 UI**를 표현하는 것이다.

즉, UI를 업데이트 할 수 있는 단 하나의 방법은 새로운 요소를 만들고 그것을 `ReactDOM.render()`로 전달하는 것 뿐이다.

```javascript
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is { new Date().toLocaleTimeString() }.</h2>
    </div>
  );
  ReactDOM.render(
    element,
    document.getElementById('root');
  );
}

setInterval(tick, 1000);
```
* [코드펜으로 확인하기](https://codepen.io/gaearon/pen/gwoJZk?editors=0010)

* Note
```bash
대부분의 React app들은 `ReactDOM.render()`를 한 번만 요청한다. 이런 코드들이 stateful(상태 저장)한 컴포넌트들로 어떻게 캡슐화 되는 지 다음 섹션에 소개된다.
```

#### 3. React Only Updates What's Necessary

React DOM은 요소의 그것의 하위 요소들을 이전 요소와 비교하고, 원하는 상태로 만드는 데 필요한 DOM 업데이트만 적용한다.

모든 UI 트리를 매초가 바뀔 때마다 새로 만들 수도 있지만, React DOM에 의해 변경되는 내용의 텍스트 노드만 업데이트 된다.

즉, React DOM의 업데이트란 시간이 지남에 따라 UI를 변경하는 방식이 아닌, 주어진 순간을 UI가 어떻게 보는 지로 생각하는 게 유용하다.